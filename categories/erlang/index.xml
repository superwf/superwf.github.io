<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>erlang on 老王的日志</title>
    <link>http://superwf.github.io/categories/erlang/</link>
    <description>Recent content in erlang on 老王的日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 28 Feb 2014 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://superwf.github.io/categories/erlang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>erlang学习</title>
      <link>http://superwf.github.io/p721/</link>
      <pubDate>Fri, 28 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>http://superwf.github.io/p721/</guid>
      <description>先是过了一遍Erlang程序设计中文版（完整书签）。
之前在html5里看过js的webworker，当时觉得看明白了，但是现在才觉得是真的明白了那玩意什么用处，也是一个进程之间的消息传递机制。
然后打算看building_web_applications_with_erlang，发现看不下去。只好又看Erlang_OTP并发编程实战，之后对OTP有了一定了解，主要是稍微熟悉了一下OTP程序的的写法和handler。
然后再看building_web_applications_with_erlang，大概明白了，但是不太看好yaws，几年来一直依赖rails的方便，这种底层的框架要自己从头写很多东西太累，也没谱。
最后提到了ChicagoBoss，是个类rails的framework。但是按照github上的教程，编译总是报错，最后连例子也跑不起来。
后来又转到了n20，看了看文档，比ChicagoBoss完善，但复杂程度也多了，短时间吃不下去。先下了个例子运行了一下，发现和传统的web程序相差太多，除了最初的页面载入之外几乎完全是用websocket来处理。为了这个又过了一遍cowboy的guide。n2o的教程反复弄了N天，也没懂，看来步子跨大了扯了蛋。后来看了nitrogen的教程http://nitrogenproject.com/doc/tutorial.html，才逐渐自己开始明白了。最后感觉n2o用的bert这个js库没用json，教程里也明确写了不支持json，大概和angularjs比较难搭配吧，弃之。看了cowboy的教程之后突然感觉直接用cowboy来写好了，将erlang和rails结合一下erlang部分做api用，rails做一些页面生成，页面用rails生成的静态html模板，后台请求都用json请求到cowboy上。
nitrogen里的wf模块令我很在意-_-，后来从源码里发现是web framework的缩写…
rebar相当于ruby的bundle，解决依赖包问题。rebar里的ling_builder，是部署到虚拟机用的，大概看了看，还不太懂，但是感觉是部署到amazon服务上用得到，自己的服务器大概不用这个。rebar与reltool.config配套使用发布。
经过几天的使用发现rebar bug多，编译的时候erlydtl模板总是报错。现在是2014年了已经，
https://github.com/rebar/rebar/issues/46这个bug现在好像还是这样，说是已经fix但是我这下载最新的rebar重新编译之后还是报错，而且每次编译能生成一个view文件，然后报错退出，改rebar.config的erlydtl_opts, [retrun_errors]也没起作用，多编译两次就都生成了，模板文件少的时候还行。erlang.mk，一开始也出错，在Makefile里加上
ERLC_OPTS =
覆盖 -Werror的选项，关闭错误报告(隐约感觉不太对，可能导致应该报错的地方也不报了)。
这样以来就可以编译了，但是默认编译模板为xxx_dtl.beam，可能需要增加个批量改名功能在Makefile里。
erlang.mk 把makefile几乎全包办了，其中解决依赖的功能和rebar有些重叠。https://medium.com/p/708597c0dd08，我个人也倾向与用erlang.mk，因为相对简单，但是n2o的那些东西全都用rebar。erlang.mk与relx.config配套发布用。
rebar的wiki，他管compile、dependency和test。rebar可以在一开始创建项目用，就像rails new一样，先创建一个骨架出来。
erlang.mk也都管这些。
relx在OTP那本书里有推荐，是书的作者之一开发的，发布erlang程序用，和erlang.mk有配套使用。
以下为备忘：
priv目录： 用于存放各种需要随应用一起发布的其他内容。包括但不限于模板文件、共享对象文件和DLL等。定位应用priv目录的方法很简单：调用code:priv_dir()，便会以字符串形式得到priv目录的完整路径。
.app 文件里的env 和 mudules书里没写，在线手册里有http://www.erlang.org/doc/design_principles/applications.html，modules是发布时将依赖一起打包的意思，env是application:get_env(app_name, env_name)用的
 html模板用slim写，再用slimrb转换，js用coffeescript写，在开发模式的时候用watchr来监视并自动编译修改过的文件。既然铁了心要用angularjs，那erlydtl模板也几乎是用不到了，全部用静态html模板就可！
riak和couchdb一样，都是有restful的api的，这样的话，除了权限安全问题不算的话，前台angularjs+后台的database就可以搞定。但安全问题靠database层应该是没戏的，中间层还是需要，但erlang都可以不用解析json，直接把前后台的数据当string传递一下即可，仅仅管理安全与权限，在必要的时候解析一下json重新包装数据。
在riak已经弄了一阵子之后，看了riak的2i和search部分，觉得riak不太适合做比较复杂的后台程序，存储基于kv，v的内容可以是任意，所以在v的内容上的搜索和索引都不会方便，导致在复杂搜索和分页方面的实现可能会有问题，不是不能实现，而是实现相对太复杂，而且可能由于程序员经验不足会导致长期不能解决的搜索效率问题，还有就是短期内不会有类似active_record那样实现模型关系的方便的封装，难道还是要用mysql，先看看couchdb吧，用基于文档的来试试。mongodb虽然更成熟一些，但在分布上面不如erlang编写的有分布优势。后来看了一下http://nosql-database.org/的分类，riak是在kv分类里，更确实了我的这个想法，我还是需要确定一个document store类型的数据库。http://labs.linkfluence.net/nosql/2011/03/07/moving_from_couchdb_to_riak.html这篇写的也是将存储转到riak上，人家也没用riak做查询用。
然后转到couchdb上，但最后由于种种原因，还是不能符合要求。</description>
    </item>
    
    <item>
      <title>about couchdb</title>
      <link>http://superwf.github.io/p749/</link>
      <pubDate>Fri, 21 Feb 2014 02:27:45 +0000</pubDate>
      
      <guid>http://superwf.github.io/p749/</guid>
      <description>从学习erlang一路到看上couchdb。看上它主要是因为map reduce，master-master deploy和couchapp这种方便的两层开发工具。
nosql无模式的特点特别吸引人，但看到最后发现用couchdb很难实现复杂查询，查询条件超过3个以上的时候，需要建立大量的视图，尤其是我做过的程序里有的查询条件有近20个，排列组合起来需要巨量视图而且还需要根据复杂的查询条件匹配到不同的视图上，虽然大部分的组合可能很少被用到吧，这玩意没法弄。看来想要从mysql完整功能迁移还是得mongodb。但mongodb就做不到省略中间层程序的rest api了。看来网页程序要做到两层还需要再发展发展。
http://www.lupaworld.com/article-215805-1.html这里的关于查询的部分差不多也是这个意思。
couchdb支持像mysql的 LIKE “abc%”这样的语句可以用startkey=”abc”&amp;amp;endkey=”abc\ufff0″这样来弄。参考如下
http://stackoverflow.com/questions/5285787/full-text-search-in-couchdb
如果只是做做blog这样的相对关系简单的东西，主要是不太需要复杂查询的还好。
CouchDB权威指南看了一半左右吧，基本操作都讲完了，已经看了部分couchapp的开发实例了就没再接着学。</description>
    </item>
    
    <item>
      <title>erlang程序设计8.2习题</title>
      <link>http://superwf.github.io/p702/</link>
      <pubDate>Fri, 10 Jan 2014 07:03:39 +0000</pubDate>
      
      <guid>http://superwf.github.io/p702/</guid>
      <description>第二题的erlang代码，用escript执行ex82文件
结果是
to 1000 processes, send 10 messages per process, cpu time is 290000 microseconds, real time is 285000 microseconds
另一个语言就用我熟悉的ruby了，用fiber，写一个ex82.rb
结果是to 1000 processes, send 10 messages per process, time is 275135.993958 microseconds
好像ruby的还快一些，不过ruby毕竟是生成的空的fiber
而erlang每个进程之间还传送了一些东西，如果ruby的fiber之间也传输消息的话，估计会多一个数量级。
等等，刚忘了，用escript执行效率低，因为是即时编译的（我是这样理解的）
把ex82改一下
另外建立一个ex82.erl
然后先编译一下
再执行ex82
结果是
这次erlang快了一个数量级了！</description>
    </item>
    
    <item>
      <title>erlang程序设计8.1习题</title>
      <link>http://superwf.github.io/p698/</link>
      <pubDate>Fri, 10 Jan 2014 06:17:13 +0000</pubDate>
      
      <guid>http://superwf.github.io/p698/</guid>
      <description>（1）编写一个函数start(AnAtom, Fun)来把spawn(Fun)的结果注册为AnAtom。当两个并行的进程同时执行到start/2函数时，要确保代码能够正常工作。也就是说，这两个进程其中一个成功执行，而另一个必须执行失败。
http://blog.lzhaohao.info/archive/a-solution-of-the-exercise-in-chapter-8-in-erlang-programming/
这里有个别人写过的结果，但我觉得不太对。
这个第一题里只是把当前进程注册成了AnAtom，并没有把Fun注册成AnAtom。
这是我第一次做的结果，是错的。保存为ex81，+x权限，用escript执行。
=结果是报错。
我的理解是start的第二个参数这个fun没有执行尾递归，所以执行了一下就结束掉了，虽然还保留了Pid，但是不能被注册，一对这个Pid执行register就会报错。
如果需要进行注册，这个函数里必须包含receive这种代码。
又写了一个
算是的到了习题的结果，两个进程只能执行一个。
但是在main里的两个start，终究感觉还是有先后执行顺序。
考虑下面这个情况
在实际的例子里可以想象成一个网络游戏，有一个gold，谁先捡到归谁，然后两个player在两个客户端都开始send take，然后gold进程本身就会执行这么一个注册程序，由于erlang里的变量都是一次性赋值，也不用加锁，不用在第一个人触发事件的时候给gold的变量加锁，而是把gold独立成一个进程。gold被捡到后会给第一个player进程send一个消息为taken success，之后的第二个乃至更多的player进程都会send taken faild的消息。这么一想，erlang的多进程确实很适合做分布式的大量响应的程序，否则其中要加锁什么的，不知逻辑上要麻烦多少倍。不过这种逻辑的东西我现在倒是还不太能做的出来，作为这个阶段的习题也太难了点。</description>
    </item>
    
  </channel>
</rss>